" Uniswap Factory (deployer of Pools). "
type Factory @entity {
  " Factory address "
  id: ID!
  " Amount of pools created "
  poolCount: BigInt!
  " Current owner of the factory "
  owner: ID!
  " Used to track if regenesis backfill has completed for Optimism."
  opBackfilled: Boolean
}

" Panoptic Factory (deployer of PanopticPools). "
type PanopticFactory @entity {
  " Factory address "
  id: ID!
  " Amount of pools created "
  poolCount: BigInt!
  " Current owner of the factory "
  owner: ID!
}

" Keeps track of ETH/USD price using a configured Uniswap pool. "
type Bundle @entity {
  id: ID!
  " Price of ETH in usd "
  ethPriceUSD: BigDecimal!
}

" Account of a Uniswap or Panoptic user. "
type Account @entity {
  " Account address "
  id: ID!
  " TokenIds owned by this account "
  accountBalances: [AccountBalance!]! @derivedFrom(field: "sender")
  " Subaccounts for PanopticPools where this Account has options activity "
  panopticPoolAccount: [PanopticPoolAccount!] @derivedFrom(field: "account")
}

# TODO: Technically, should index each issued ERC-721 for NFPM positions | ERC-1155 for SFPM issued positions | & transfers to account for owner changes
" The AccountBalance entity represents how many of a specific TokenId an Account holds "
type AccountBalance @entity {
  # TODO: need a count / second address / txnhash + logindex in the ID here to distinguish different positions. For example, distinguishing SFPM from PanopticPool (mint,burn)s of the same tokenId from the same user.
  " Sender (e.g. user address) + '#' + tokenId, to distinguish NFPM positions from PanopticPool positions "
  id: ID!
  " Creator of this AccountToken balance (e.g. NFPM Account, SFPM Account, PanopticPool) "
  owner: Account!
  " Initiator of this txn (account responsible) "
  sender: Account!
  " The ERC1155 TokenId held by this Account "
  tokenId: TokenId!

  " The Legs and associated liquidity amounts of this AccountBalance's TokenId "
  legLiquidities: [LegLiquidities!]!

  " Amount of TokenId held by this Account "
  tokenCount: BigInt! @deprecated(reason: "Use positionSize")

  " Position size expressed in terms of the asset "
  positionSize: BigInt!

  " The associated PanopticPoolAccount IF the TokenId exists within a PanopticPool. Null if the tokenId exists outside of a PanopticPool, like an LP position created through direct interaction with the SFPM / NFPM. "
  panopticPoolAccount: PanopticPoolAccount
  " ID of the event that created account balance "
  txnOpened: Event!
  " ID of the event that closed account balance "
  txnClosed: Event

  " Open state of this Position. Will be 0 if closed, 1 if open, and 2 if there is another closed copy of this account balance and this instance is just a placeholder waiting to get overwritten."
  isOpen: Int!

  " Creation timestamp "
  createdTimestamp: BigInt!
  " Creation block number "
  createdBlockNumber: BigInt!
  " Closed timestamp "
  closedTimestamp: BigInt
}

" Tracks Panoption & PLP activity (collateral withdrawals and deposits) for a given Account & PanopticPool the Account has interacted with. " 
type PanopticPoolAccount @entity {
  " Address of account + '#' + address of panoptic pool "
  id: ID!
  " Panoptic pool address "
  panopticPool: PanopticPool!

  " Account address "
  account: Account!

  # Collateral balances for a given account in a given Panoptic Pool
  # There will be 2 per PanopticPool, one for each token
  " Collateral contract for Token0 "
  collateral0: Collateral!
  " Number of collateral shares Collateral0 "
  collateral0Shares: BigInt!
  " Number of collateral assets Collateral0 "
  collateral0Assets: BigInt!
  " Collateral contract for Token1 "
  collateral1: Collateral!
  " Number of collateral shares Collateral1 "
  collateral1Shares: BigInt!
  " Number of collateral assets Collateral1 "
  collateral1Assets: BigInt!

  # Fee accumulators
  " All time commissions paid to PLPs in Collateral0. Commissions increase with every OptionMint and collateral deposit. "
  commissions0: BigDecimal!
  # TODO: add commissions0USD
  " All time commissions paid to PLPs in Collateral1. "
  commissions1: BigDecimal!
  # TODO: add commissions1USD
  # TODO: also calc volume
  # And create volume, volumeUSD, commissionsUSD, and shareprice fields.
  # Once those are done, aggregate them all on a daily basis
  " Collateral0 share price at time of last transfer (an internal bookeeping mechanism to keep track of total commissions this account has earned as a PLP). "
  sharePriceAtLastTransfer0: BigDecimal!
  " See sharePriceAtLastTransfer0. "
  sharePriceAtLastTransfer1: BigDecimal!
  " Commissions earned in token0 since this account's last share transfer event (shares get transferred when depositing or withdrawing collateral, burning or minting an option, or directly sending share tokens). "
  commissionsSinceLastTransfer0: BigDecimal!
  " Same as `commissionsSinceLastTransfer`, but in token1. "
  commissionsSinceLastTransfer1: BigDecimal!

  " Whether or not the user has been liquidated for this pool & not opened new positions (1 if true) "
  isLiquidated: Int!

  " TokenId balances that this PanopticPoolAccount is responsible for "
  accountBalances: [AccountBalance!]! @derivedFrom(field: "panopticPoolAccount")

  # TODO: add link to collateralDeposits & CollateralWithdraw w/ @derivedFrom
}

# ERC20 token tradeable in Uniswap
type Token @entity {
  " Token address "
  id: ID!
  " Token decimals "
  decimals: BigInt!
  " Token name "
  name: String!
  " Token symbol "
  symbol: String!
  " Token total supply "
  totalSupply: BigInt!
  " Number of transactions across all pools that include this token "
  txCount: BigInt!

  " Derived price in ETH, used to provide human readable price "
  derivedETH: BigDecimal!

  " Pools token is in that are white listed for USD pricing "
  whitelistPools: [Pool!]!
}

" Underlying pool (e.g. Uniswap V3 Pool) "
type Pool @entity {
  " Pool address "
  id: ID!
  " Panoptic identifier of uniswap pool "
  poolId: String
  " Fee amount "
  feeTier: BigInt!
  " Min space between ticks "
  tickSpacing: BigInt!
  " Token0 "
  token0: Token!
  " Token1 "
  token1: Token!
  " Total transaction count "
  txCount: BigInt!

  " In range liquidity "
  liquidity: BigInt!
  " Current price tracker "
  sqrtPrice: BigInt!
  " Current tick. May be null if pool has not been initialized. "
  tick: BigInt
  " Timestamp of the last time this tick was updated "
  tickLastUpdateTimestamp: BigInt!
  " Block number of the last time this tick was updated "
  tickLastUpdateBlockNumber: BigInt!

  " Snapshots of PoolHourData "
  poolHourData: [PoolHourData!]! @derivedFrom(field: "pool")
  " Snapshots of PoolDayData "
  poolDayData: [PoolDayData!]! @derivedFrom(field: "pool")

  # My additions, based on og uniswap subgraph
  " token0 per token1 "
  token0Price: BigDecimal!
  " Token1 per token0 "
  token1Price: BigDecimal!
  " Total token 0 across all ticks "
  totalValueLockedToken0: BigDecimal!
  " Total token 1 across all ticks "
  totalValueLockedToken1: BigDecimal!
  " Tvl derived ETH (necessary for tvlUSD using uni's implementation) "
  totalValueLockedETH: BigDecimal!
  " Tvl USD "
  totalValueLockedUSD: BigDecimal!

  " Associated PanopticPool. Null if not created yet "
  panopticPool: PanopticPool
}

" A chunk of liquidity. Used to track liquidity available in Uniswap, as well as liquidity removed from Uniswap for use in PanopticPools. "
type Chunk @entity {
  " ID is a concatenated string of: owner + '#' + manager + '#' + poolAddress + '#' + tokenType + '#' + lowerTick + '#' + upperTick "
  id: ID!
  " TokenizedPositionMinted.caller if mint routes through SFPM. Otherwise, same as manager (will be a PanopticPool address for option mints/burns/rolls). "
  owner: Account!
  " Mint.sender / Burn.owner on Uniswap pool event "
  manager: Account!
  " Lower tick of the position "
  tickLower: BigInt!
  " Upper tick of the position "
  tickUpper: BigInt!
  " Avg. of tickLower & tickUpper "
  strike: BigInt!
  " (tickUpper - tickLower) / pool.tickSpacing "
  width: BigInt!
  " Which token is moved when deployed (0 -> token0, 1 -> token1). When minted through Uniswap's NFPM, tokenType is always 1 (for put). "
  tokenType: BigInt!
  " Pool where this chunk exists "
  pool: Pool!

  " If owned by a PanopticPool, PanopticPool that owns this chunk "
  panopticPool: PanopticPool

  # The rules for modifying total, net, short, and long liquidity are as follows:
  # If txn is sent from NFPM, mint adds to total liquidity, adds to net & short liquidity, long has no meaning.
  # If txn is sent from NFPM, burn decreases total liquidity, decreases net & short liquidity.

  # If txn is sent from SFPM, if a leg has isLong=0, and SFPM emits TokenizedPositionMinted. it is minting liquidity into uniswap, so increment net, total, and short liquidity
  # If txn sent from SFPM, if a leg has isLong=1, and SFPM emits TokenizedPositionMinted, it is burning liquidity from uniswap, so decrease net, increases long, and doesn't touch totalLiquidity
  # If txn sent from SFPM, if a leg has isLong=0, and SFPM emits TokenizedPositionBurnt, it is burning liquidity from uniswap, so decrease net, decrease short, and decrease totalLiquidity
  # If txn sent from SFPM, if a leg has isLong=1, and SFPM emits TokenizedPositionBurnt, it is minting liquidity into uniswap, so increase net, decrease long, and doesn't touch totalLiquidity

  " Net liquidity in chunk "
  netLiquidity: BigInt!
  " Short liquidity in chunk "
  shortLiquidity: BigInt!
  " Long liquidity in chunk "
  longLiquidity: BigInt!
  " Total long positions in chunk "
  shortCounts: BigInt!
  " Total short positions in chunk "
  longCounts: BigInt!
  " Total liquidity in chunk "
  totalLiquidity: BigInt!

  " Legs created on this chunk of liquidity "
  legs: [Leg!]! @derivedFrom(field: "chunk")
}

" A leg of a TokenId, representing a single option. "
type Leg @entity {
  """
  Id is the tuple (asset, optionRatio, isLong, tokenType, riskPartner, strike, width) from LSB to MSB, in BigInt form, cast to a string
  See TokenId entity for more details, or the source here: https://github.com/panoptic-labs/Panoptic/blob/b33788f414d3101448309212dd66654e63c6a31d/contracts/libraries/TokenId.sol#L29
  """
  id: ID!
  " Index of the leg in the tokenId "
  index: Int!
  " Hex stringified leg ID "
  idHexString: String!
  " Pool position is within "
  pool: Pool!
  " Number of contracts per leg "
  optionRatio: BigInt!
  " Asset of 0 token0, 1 for token1 "
  asset: BigInt!
  " Token type "
  tokenType: BigInt!
  " Is it a long leg? "
  isLong: BigInt!
  " Risk partner "
  riskPartner: BigInt!
  " Strike "
  strike: BigInt!
  " Width "
  width: BigInt!
  " Chunk data "
  chunk: Chunk!

  " How many of this Leg exist "
  legCount: BigInt!
  " TokenIds which this leg exists in "
  tokenIds: [TokenId!]! @derivedFrom(field: "legs")
}

" Currently only for Panoptic TokenIds (not synthetic tokenIds created from uniswap positions), stores the liquidity underlying each instance of a leg. While multiple legs may exist with the same ID, each instance of a leg controls a fixed amount of liquidity when active. Can also think of these as the 'operators' of a given chunk. Don't directly own the liquidity (like PanopticPool) or manage it (like SFPM), but the account that owns this Leg has the right to instruct the manager on how to manage the underlying liquidity. The 'operator' wasn't added to Chunk IDs to avoid fragmentation of the entities - we would quickly reach the 1000 query limit otherwise. Maybe this will be removed in favor of a simple 'operator' field in Chunk in the future. "
type LegLiquidities @entity {
  " leg id + '#' + txnHash + '#' + logIndex "
  id: ID!
  leg: Leg!
  chunk: Chunk!
  liquidity: BigInt!
}

" An ERC-1155 ID representing a position. "
type TokenId @entity {
  """
  The ERC-1155 TokenId for this position. See the TokenId.sol for more information on its structure.
  """
  # TokenId Structure pasted here for developer reference:
  # See: https://github.com/panoptic-labs/Panoptic/blob/b33788f414d3101448309212dd66654e63c6a31d/contracts/libraries/TokenId.sol#L28 for more.
  # @dev PACKING RULES FOR A TOKENID:
  # @dev this is how the token Id is packed into its bit-constituents containing position information.
  # @dev the following is a diagram to be read top-down in a little endian format
  # @dev (so (1) below occupies the first 64 least significant bits, e.g.):
  # @dev From the LSB to the MSB:
  # ===== 1 time (same for all legs) ==============================================================
  #      Property         Size      Offset      Comment
  # (1) univ3pool        64bits     0bits      : first 8 bytes of the Uniswap v3 pool address (first 64 bits; little-endian)
  # ===== 4 times (one for each leg) ==============================================================
  # (2) asset         1bit      0bits      : Specifies the asset (0: token0, 1: token1)
  # (3) optionRatio       7bits     1bits      : number of contracts per leg
  # (4) isLong            1bit      8bits      : long==1 means liquidity is removed, long==0 -> liquidity is added
  # (5) tokenType         1bit      9bits      : put/call: which token is moved when deployed (0 -> token0, 1 -> token1)
  # (6) riskPartner       2bits     10bits     : normally its own index. Partner in defined risk position otherwise
  # (7) strike           24bits     12bits     : strike price; defined as (tickUpper + tickLower) / 2
  # (8) width            12bits     36bits     : width; defined as (tickUpper - tickLower) / 2
  # Total                48bits                : Each leg takes up this many bits
  # ===============================================================================================
  # The bit pattern is therefore, in general:
  
  #                        (strike price tick of the 3rd leg)
  #                            |             (width of the 2nd leg)
  #                            |                   |
  # (8)(7)(6)(5)(4)(3)(2)  (8)(7)(6)(5)(4)(3)(2)  (8)(7)(6)(5)(4)(3)(2)   (8)(7)(6)(5)(4)(3)(2)        (1)
  #  <---- 48 bits ---->    <---- 48 bits ---->    <---- 48 bits ---->     <---- 48 bits ---->    <- 64 bits ->
  #         Leg 4                  Leg 3                  Leg 2                   Leg 1         Univ3 Pool Address
  
  #  <--- most significant bit                                                       least significant bit --->
  id: ID!
  " Hex stringified tokenId "
  idHexString: String!
  " Pool position is within "
  pool: Pool!
  # " How many of this TokenId exist "
  # TODO: rename to positionSize
  " Also known as positionSize, the total net number of contracts for this tokenId, expressed in terms of the asset "
  tokenCount: BigInt!

  # TODO:
  # " The total net number of contracts for this tokenId, expressed in terms of the asset "
  # positionSize: BigInt!

  " AccountBalances that own an instance of this TokenId"
  accountBalances: [AccountBalance!]! @derivedFrom(field: "tokenId")

  " Legs in this tokenId "
  legs: [Leg!]!
}

" Contains the collateralization metrics of a certain token in a certain PanopticPool (derived from the CollateralTracker.sol contract). "
type Collateral @entity {
  " Address of CollateralTracker for pool "
  id: ID!
  " Address of underlying token "
  token: Token!
  " Token asset supply "
  totalAssets: BigInt!
  " Total shares supply (receipts to claim assets) "
  totalShares: BigInt!
  " Tokens in AMM "
  inAMM: BigInt!

  # Pool utilization represents how many funds are in the Panoptic pool versus the AMM pool.
  # Currently, would need a lot of work to track this in the subgraph (need new PoolUtilizationChanged event throughout the contracts).
  # Consumers can fetch it on chain by querying CollateralTracker contract's getPoolData method.
  # poolUtilization: BigInt! 

  " The PanopticPool being collateralized "
  panopticPool: PanopticPool!
  " Index of 0 or 1, indicating if this is collateralTracker0 or collateralTracker1 in its parent PanopticPool "
  index: BigInt!

  " Snapshots of CollateralDayData "
  collateralDayData: [CollateralDayData!]! @derivedFrom(field: "collateral")

  " Share price before most recent transfer event. Useful for calculating commissions. "
  previousSharePrice: BigDecimal!

  """ Share price immediately before calling liquidate() used for calculating protocol loss. Starts as 0 and
  gets updated when a _mint() call is being handled during a liquidation (nonzero share transfer from 0 address -> liquidator).
  Gets reset when handling a Deposit() event (which is the only other time transfer from 0 address -> liquidator would happen)
  or after being used by the AccountLiquidated() event handler. """
  preLiquidationSharePrice: BigDecimal!
}

" A pool deployed on top of an existing Uniswap Pool to facilitate perpetual options trading. "
type PanopticPool @entity {
  " Pool address "
  id: ID!
  " Total transaction count "
  txCount: BigInt!
  " Token0 "
  token0: Token!
  " Token1 "
  token1: Token!
  " Fee amount "
  feeTier: BigInt!
  " Vault for token 0 collateral "
  collateral0: Collateral!
  " Vault for token 1 collateral "
  collateral1: Collateral!
  " Underlying pool "
  underlyingPool: Pool!
  # " The id of the Factory-issued rare NFT minted as part of deploying the Panoptic pool (NOT the option position in the SFPM) "
  # rareNftId: BigInt!
  # " The rarity of the deployed Panoptic Pool (associated with a rare NFT). "
  # rarity: BigInt!

  " All time commissions earned from Collateral0. Commissions increase with every OptionMint and collateral deposit. They may decrease in case of protocol loss, which gets realized as part of a liquidation. "
  commissions0: BigDecimal!
  " All time commissions earned from Collateral1. "
  commissions1: BigDecimal!
  " The protocol loss in token0. Protocol loss is the value of shares added to the supply in the event of liquidation of bad debt. "
  protocolLoss0: BigDecimal!
  " The protocol loss in token1."
  protocolLoss1: BigDecimal!

  " Link to all chunks of liquidity that are valid for options buying from this PanopticPool "
  chunks: [Chunk!]! @derivedFrom(field: "panopticPool")
}

#    _     ________ __  ____  __ _   _ _        _  _____ ___  ____  ____
#   / \  / ___/ ___| | | |  \/  | | | | |      / \|_   _/ _ \|  _ \/ ___|
#  / _ \| |  | |   | | | | |\/| | | | | |     / _ \ | || | | | |_) \___ \
# / ___ \ |__| |___| |_| | |  | | |_| | |___ / ___ \| || |_| |  _ < ___) |
#/_/   \_\____\____|\___/|_|  |_|\___/|_____/_/   \_\_| \___/|_| \_\____/
# time-series data accumulators

" Data accumulated and condensed into day stats for each pool "
type PoolDayData @entity {
  " Timestamp rounded to current day by dividing by 86400 "
  id: ID!
  " Pointer to Cool "
  pool: Pool!
  " Timestamp rounded to current day by dividing by 86400 "
  date: Int!
  " Number of transactions during period "
  txCount: BigInt!

  " In range liquidity at end of period "
  liquidity: BigInt!

  " Price of token0 - derived from sqrtPrice "
  token0Price: BigDecimal!
  " Price of token1 - derived from sqrtPrice "
  token1Price: BigDecimal!

  " Volume in token0 "
  volumeToken0: BigDecimal!
  " Volume in token1 "
  volumeToken1: BigDecimal!
  " Volume in USD "
  volumeUSD: BigDecimal!
  " Fees in USD "
  feesUSD: BigDecimal!

  " Opening price of token0 "
  open: BigDecimal!
  " High price of token0 "
  high: BigDecimal!
  " Low price of token0 "
  low: BigDecimal!
  " Close price of token0 "
  close: BigDecimal!
}

" Data accumulated and condensed into day stats for each collateral "
type CollateralDayData @entity {
  " Timestamp rounded to current day by dividing by 86400 "
  id: ID!
  " Pointer to Collateral "
  collateral: Collateral!
  " Timestamp rounded to current day by dividing by 86400 "
  date: Int!

  " Shares "
  totalShares: BigInt!
  " Assets "
  totalAssets: BigInt!
  " Share price (assets/shares) "
  sharePrice: BigDecimal!
}

type PoolHourData @entity {
  " Format: <pool address>#<timestamp> "
  id: ID!
  " Pointer to pool "
  pool: Pool!
  " Number of transactions during period "
  txCount: BigInt!

  " In range liquidity at end of period "
  liquidity: BigInt!

  " Price of token0 - derived from sqrtPrice "
  token0Price: BigDecimal!
  " Price of token1 - derived from sqrtPrice "
  token1Price: BigDecimal!

  " Volume in token0 "
  volumeToken0: BigDecimal!
  " Volume in token1 "
  volumeToken1: BigDecimal!
  " Volume in USD "
  volumeUSD: BigDecimal!

  " Opening price of token0 "
  open: BigDecimal!
  " High price of token0 "
  high: BigDecimal!
  " Low price of token0 "
  low: BigDecimal!
  " Close price of token0 "
  close: BigDecimal!

  " Unix timestamp for start of hour "
  periodStartUnix: Int!
}

# _                    _                   _   _____                 _
#| |    _____      __ | |    _____   _____| | | ____|_   _____ _ __ | |_ ___
#| |   / _ \ \ /\ / / | |   / _ \ \ / / _ \ | |  _| \ \ / / _ \ '_ \| __/ __|
#| |__| (_) \ V  V /  | |__|  __/\ V /  __/ | | |___ \ V /  __/ | | | |_\__ \
#|_____\___/ \_/\_/   |_____\___| \_/ \___|_| |_____| \_/ \___|_| |_|\__|___/
# Low level events

enum EventType {
  " UniswapPool "
  Mint
  Burn
  Collect
  " SemiFungiblePositionManager "
  TokenizedPositionBurnt
  TokenizedPositionMinted
  TokenizedPositionRolled
  " CollateralTracker "
  Deposit
  Withdraw
  " PanopticPool "
  OptionMint
  OptionBurn
  OptionRoll
  AccountLiquidated
  ForcedExercised
  PremiumSettled
}

" A generic entity for the many events that get emitted throughout the Panoptic protocol. "
interface Event @entity {
  " Txn hash + '#' + log index "
  id: ID!
  " Txn hash of the transaction emitting this event "
  hash: String!
  " Event log index "
  logIndex: BigInt!
  " Sender of transaction "
  from: String!
  " Receiver of transaction "
  to: String!
  " Block txn was included in "
  blockNumber: BigInt!
  " Timestamp txn was confirmed "
  timestamp: BigInt!
  " Gas used during txn execution "
  gasUsed: BigInt!
  " Gas price during txn execution "
  gasPrice: BigInt!
  " Type of event. The Graph doesn't allow filtering by __typename meta so it's explicitly required here "
  eventType: EventType!
  " Uniswap Pool the event happened within, or the underlying Uniswap Pool for a PanopticPool event. Needed to show all transactions within a pool from a certain account because The Graph doesn't have the ability to add custom filters. "
  pool: Pool!
}

" Uniswap liquidity mint "
type Mint implements Event @entity(immutable: true) {
  # Required Event fields:

  id: ID!
  hash: String!
  logIndex: BigInt!
  eventType: EventType!
  from: String!
  to: String!
  blockNumber: BigInt!
  timestamp: BigInt!
  gasUsed: BigInt!
  gasPrice: BigInt!
  pool: Pool!

  # Mint event specific fields:
  " The address that minted the liquidity "
  sender: Account!
  " Owner of position where liquidity minted to "
  owner: Account!
  " Lower tick of the position "
  tickLower: Int!
  " Upper tick of the position "
  tickUpper: Int!
  " Amount of liquidity minted "
  amount: BigInt!
  " Amount of token 0 minted "
  amount0: BigDecimal!
  " Amount of token 1 minted "
  amount1: BigDecimal!

  # Other fields that we specify:

  " Allow indexing by tokens "
  token0: Token!
  " Allow indexing by tokens "
  token1: Token!
}

" Uniswap liquidity burn "
type Burn implements Event @entity(immutable: true) {
  # Required Event Fields:

  id: ID!
  hash: String!
  logIndex: BigInt!
  eventType: EventType!
  from: String!
  to: String!
  blockNumber: BigInt!
  timestamp: BigInt!
  gasUsed: BigInt!
  gasPrice: BigInt!
  pool: Pool!

  # Burn event specific fields:
  " The owner of the position for which liquidity is removed "
  owner: Account!
  " The lower tick of the position "
  tickLower: Int!
  " The upper tick of the position "
  tickUpper: Int!
  " The amount of liquidity to remove "
  amount: BigInt!
  " The amount of token 0 withdrawn "
  amount0: BigDecimal!
  " The amount of token 1 withdrawn "
  amount1: BigDecimal!

  # Other fields that we specify:

  " Allow indexing by tokens "
  token0: Token!
  " Allow indexing by tokens "
  token1: Token!
}

" Uniswap collect "
type Collect implements Event @entity(immutable: true) {
  # Required Event fields:
  id: ID!
  hash: String!
  logIndex: BigInt!
  eventType: EventType!
  from: String!
  to: String!
  blockNumber: BigInt!
  timestamp: BigInt!
  gasUsed: BigInt!
  gasPrice: BigInt!
  pool: Pool!

  # Collect event specific fields:
  " The owner of the position for which fees are collected "
  owner: Account!
  " The address that received the output of the collect "
  recipient: Account!
  " The lower tick of the position "
  tickLower: Int!
  " The upper tick of the position "
  tickUpper: Int!
  " The amount of token0 fees collected "
  amount0: BigDecimal!
  " The amount of token1 fees collected "
  amount1: BigDecimal!

  # Other fields that we specify:
}

" SFPM tokenized position burn "
type TokenizedPositionBurnt implements Event @entity(immutable: true) {
  # Required Event fields:
  id: ID!
  hash: String!
  logIndex: BigInt!
  eventType: EventType!
  from: String!
  to: String!
  blockNumber: BigInt!
  timestamp: BigInt!
  gasUsed: BigInt!
  gasPrice: BigInt!
  pool: Pool!

  # TokenizedPositionBurnt event specific fields:
  " User that burnt the position "
  recipient: Account!
  " The number of contracts burnt, expressed in terms of the asset "
  positionSize: BigInt!
  " TokenId of the burnt option "
  tokenId: TokenId!

  # Other fields that we specify:
}

" SFPM tokenized position mint "
type TokenizedPositionMinted implements Event @entity(immutable: true) {
  # Required Event fields:
  id: ID!
  hash: String!
  logIndex: BigInt!
  eventType: EventType!
  from: String!
  to: String!
  blockNumber: BigInt!
  timestamp: BigInt!
  gasUsed: BigInt!
  gasPrice: BigInt!
  pool: Pool!

  # TokenizedPositionMinted event specific fields:
  " User that minted the position "
  caller: Account!
  " The number of contracts minted, expressed in terms of the asset "
  positionSize: BigInt!
  " TokenId of the minted position "
  tokenId: TokenId!

  # Other fields that we specify:
}

" SFPM tokenized position roll "
type TokenizedPositionRolled implements Event @entity(immutable: true) {
  # Required Event fields:
  id: ID!
  hash: String!
  logIndex: BigInt!
  eventType: EventType!
  from: String!
  to: String!
  blockNumber: BigInt!
  timestamp: BigInt!
  gasUsed: BigInt!
  gasPrice: BigInt!
  pool: Pool!

  # TokenizedPositionRolled event specific fields:
  " User that rolled the position "
  recipient: Account!
  " TokenId of the burnt position "
  oldTokenId: TokenId!
  " TokenId of the newly minted position "
  newTokenId: TokenId!
  " The number of contracts rolled, expressed in terms of the asset "
  positionSize: BigInt!

  # Other fields that we specify:
}

" Collateral deposit (PLP liquidity deposit) "
type CollateralDeposit implements Event @entity(immutable: true) {
  # Required Event fields:
  id: ID!
  hash: String!
  logIndex: BigInt!
  eventType: EventType!
  from: String!
  to: String!
  blockNumber: BigInt!
  timestamp: BigInt!
  gasUsed: BigInt!
  gasPrice: BigInt!
  pool: Pool!

  # CollateralDeposit event specific fields:
  " The address of the caller (and depositor) "
  sender: Account!
  " The address of the recipient of the newly minted shares "
  owner: Account!
  " The amount of assets deposited by `sender` in exchange for `shares` "
  assets: BigInt!
  " Shares the amount of shares minted to `owner` "
  shares: BigInt!
  " The collateral entity that received the deposit. "
  collateral: Collateral!

  # Other fields that we specify:
  tickAtDeposit: BigInt
  tokenDerivedEthAtDeposit: BigDecimal!
  ethPriceUSDAtDeposit: BigDecimal!
}

" Collateral deposit (PLP liquidity withdrawal) "
type CollateralWithdraw implements Event @entity(immutable: true) {
  # Required Event fields:
  id: ID!
  hash: String!
  logIndex: BigInt!
  eventType: EventType!
  from: String!
  to: String!
  blockNumber: BigInt!
  timestamp: BigInt!
  gasUsed: BigInt!
  gasPrice: BigInt!
  pool: Pool!

  # CollateralWithdraw event specific fields:
  " The address of the caller "
  sender: Account!
  " The address of the recipient of the withdrawn assets "
  receiver: Account!
  " The address of the owner of the shares being burned "
  owner: Account!
  " The amount of assets withdrawn to `receiver` "
  assets: BigInt!
  " The amount of shares burned by `owner` in exchange for `assets` "
  shares: BigInt!
  " The collateral entity that was withdrawn from. "
  collateral: Collateral!

  # Other fields that we specify:
  tickAtWithdraw: BigInt
  tokenDerivedEthAtWithdraw: BigDecimal!
  ethPriceUSDAtWithdraw: BigDecimal!
}

" Panoption mint / position open "
type OptionMint implements Event @entity(immutable: true) {
  # Required Event fields:
  id: ID!
  hash: String!
  logIndex: BigInt!
  eventType: EventType!
  from: String!
  to: String!
  blockNumber: BigInt!
  timestamp: BigInt!
  gasUsed: BigInt!
  gasPrice: BigInt!
  pool: Pool!

  # OptionMinted event specific fields:
  " User that minted the option "
  recipient: Account!
  " The number of contracts minted, expressed in terms of the asset "
  positionSize: BigInt!
  " TokenId of the created option "
  tokenId: TokenId!
  " Tick at which the option was minted "
  tickAt: Int!
  " Packing of the pool utilization (how much funds are in the Panoptic pool versus the AMM pool) at the time of minting. Right 64bits for token0 and left 64bits for token1, defined as (inAMM / totalBalance) * 10_000 "
  poolUtilizations: BigInt!
  " PanopticPool mint is within (from event.address) "
  panopticPool: PanopticPool!

  " Token0 commissions paid to mint this option "
  commissions0: BigDecimal!
  " Token1 commissions paid to mint this option "
  commissions1: BigDecimal!

  # Other fields that we specify:

  " Pool utilization token0 "
  poolUtilization0: BigInt!
  " Pool utilization token1 "
  poolUtilization1: BigInt!
}

" Panoption burn / position close "
type OptionBurn implements Event @entity(immutable: true) {
  # Required Event fields:
  id: ID!
  hash: String!
  logIndex: BigInt!
  eventType: EventType!
  from: String!
  to: String!
  blockNumber: BigInt!
  timestamp: BigInt!
  gasUsed: BigInt!
  gasPrice: BigInt!
  pool: Pool!

  # OptionBurnt event specific fields:
  " User that burnt the option "
  recipient: Account!
  " The number of contracts burnt, expressed in terms of the asset "
  positionSize: BigInt!
  " TokenId of the burnt option "
  tokenId: TokenId!
  " Tick at which the option was burned "
  tickAt: Int!
  " The amount of premia collected "
  premia: BigInt!
  " PanopticPool mint is within (from event.address) "
  panopticPool: PanopticPool!

  # Other fields that we specify:
  " Premium collected for token0 "
  premium0: BigInt!
  " Premium collected for token1 "
  premium1: BigInt!
  " ID of the corresponding OptionMint "
  txnOpened: OptionMint!

  " If this optionBurn was due to a position being exercised, this will be the ID of the related ForceExercise event. "
  forcedExercise: ForcedExercise

  " If this optionBurn was due to a PanopticPoolAccount being liquidated, this will be the ID of the related AccountLiquidated event. "
  accountLiquidated: AccountLiquidated
}

type OptionRoll implements Event @entity(immutable: true) {
  # Required Event fields:
  id: ID!
  hash: String!
  logIndex: BigInt!
  eventType: EventType!
  from: String!
  to: String!
  blockNumber: BigInt!
  timestamp: BigInt!
  gasUsed: BigInt!
  gasPrice: BigInt!
  pool: Pool!

  # OptionRolled event specific fields:
  " User that burnt the option "
  recipient: Account!
  " The number of contracts burnt, expressed in terms of the asset "
  positionSize: BigInt!
  " TokenId of the burnt option "
  oldTokenId: BigInt!
  " TokenId of the minted option "
  newTokenId: BigInt!
  " Tick at which the option was rolled "
  tickAtRoll: Int!
  " Packing of the pool utilization (how much funds are in the Panoptic pool versus the AMM pool) at the time of minting. Right 64bits for token0 and left 64bits for token1, defined as (inAMM / totalBalance) * 10_000 "
  poolUtilizations: BigInt!
  " LeftRight packing for the amount of premia collected for token0 and token1 "
  premia: BigInt!
  " PanopticPool roll is within (from event.address) "
  panopticPool: PanopticPool!

  # Other fields that we specify:

  " Pool utilization token0 "
  poolUtilization0: BigInt!
  " Pool utilization token1 "
  poolUtilization1: BigInt!
  " Premium collected for token0 "
  premium0: BigInt!
  " Premium collected for token1 "
  premium1: BigInt!
}

" Liquidation of a distressed PanopticPoolAccount. All of the distressed account's positions in a specific PanopticPool get closed and the liquidator receives a bonus. "
type AccountLiquidated implements Event @entity {
  # Required Event fields:
  id: ID!
  hash: String!
  logIndex: BigInt!
  eventType: EventType!
  from: String!
  to: String!
  blockNumber: BigInt!
  timestamp: BigInt!
  gasUsed: BigInt!
  gasPrice: BigInt!
  pool: Pool!

  # AccountLiquidated event specific fields:
  " Address that liquidates the distressed account "
  liquidator: Account!
  " Address of the distressed/liquidated account "
  liquidatee: Account!
  " LeftRight encoding for the the bonus paid for token 0 (right slot) and 1 (left slot) from the Panoptic Pool to the liquidator. See liquidationBonus0 and liquidationBonus1 for the unpacked token values. "
  bonusAmounts: BigInt!
  " The amount of bonus paid for token0 for this liquidation. "
  liquidationBonus0: BigInt!
  " The amount of bonus paid for token1 for this liquidation. "
  liquidationBonus1: BigInt!
  " Tick when the position was liquidated "
  tickAt: Int!
  " The PanopticPool this liquidation happened in (from event.address) "
  panopticPool: PanopticPool!

  # Other fields that we specify:
  " List of OptionBurn events resulting from this Liquidation "
  optionBurns: [OptionBurn!] @derivedFrom(field: "accountLiquidated")
}

" Force the exercise of a single position. Exercisor will have to pay a fee to the force exercisee. "
type ForcedExercise implements Event @entity {
  # Required Event fields:
  id: ID!
  hash: String!
  logIndex: BigInt!
  eventType: EventType!
  from: String!
  to: String!
  blockNumber: BigInt!
  timestamp: BigInt!
  gasUsed: BigInt!
  gasPrice: BigInt!
  pool: Pool!

  # ForcedExercised event specific fields:
  " Address of the account that forces the exercise of the position "
  exercisor: Account!
  " Address of the owner of the liquidated position "
  user: Account!
  " TokenId of the liquidated position "
  tokenId: BigInt!
  " LeftRight encoding for the cost paid by the exercisor to force the exercise of the token. The token0 fee is in the right slot, and token1 fee is in the left slot. "
  exerciseFee: BigInt!
  " The cost paid by the exercisor to force the exercise for token0 (represented as a negative value, fee debited) "
  exerciseFee0: BigInt!
  " The cost paid by the exercisor to force the exercise for token1 (represented as a negative value, fee debited) "
  exerciseFee1: BigInt!
  " Tick when the position was exercised "
  tickAt: Int!
  " The PanopticPool this forced exercise happened in (from event.address) "
  panopticPool: PanopticPool!

  # Other fields that we specify:
  " OptionBurn event for the exercised position "
  optionBurn: OptionBurn @derivedFrom(field: "forcedExercise")
}

" Emitted when premium is settled independent of a mint/burn (e.g. during `settleLongPremium`)"
type PremiumSettled implements Event @entity(immutable: true) {
  # Required Event fields:
  id: ID!
  hash: String!
  logIndex: BigInt!
  eventType: EventType!
  from: String!
  to: String!
  blockNumber: BigInt!
  timestamp: BigInt!
  gasUsed: BigInt!
  gasPrice: BigInt!
  pool: Pool!

  # PremiumSettled event specific fields:
  "Address of the owner of the settled position"
  user: Account!
  "TokenId of the settled position"
  tokenId: TokenId!
  "LeftRight encoding for the amount of premium settled for token0 (right slot) and token1 (left slot)"
  settledAmounts: BigInt!

  # Other fields that we specify:
  "Amount settled for token0"
  settledAmount0: BigInt!
  "Amount settled for token1"
  settledAmount1: BigInt!
  "PanopticPool mint is within (from event.address)"
  panopticPool: PanopticPool!
}
